\newpage
\section{Visualisierung}
\label{visualisierung}
Zwar würden für die Implementierung des Versuchsaufbaus die von Unity vorgegebenen Primitive ausreichend sein, um die reine Funktionalität des Ansatzes zu testen. Jedoch wäre dies für den Nutzer wenig anschaulich und kann teilweise, zu Fehlern in der Anwendung führen. Dies kann passieren, wenn nicht genügend visuelle Anhaltspunkte gegeben werden, um die Richtigkeit der Anwendung damit zu überprüfen. Die Betrachtung des Fehlerelements ist aber ein beiläufiger Aspekt und soll deswegen nicht weiter in diesem Kapitel betrachtet werden. 
\\
Um die Visualisierung anschaulicher zu gestalten, müssen verschiedene Modelle erstellt werden, die in ihrem Stil kohärent sind. Dies erhöht die Immersion des Nutzers. Ich habe mich für eine stilisierte Umgebung entschieden, die realistische Elemente mit einem Cartoon Style paart. Ziel war es, einen verspielten Stil zu implementieren, der die Erkennbarkeit der Objekte jedoch nicht erschwert. 
Für die Modellierung wurde die Open Source Software Blender verwendet. In dieser können sowohl 3D wie auch 2D Objekte erstellt werden. Blender liefert eine Vielzahl an Funktionalitäten, von denen für dieses Projekt nur ein Bruchteil verwendet wurde. Modellierung, Sculpting, VFX, Animation, Rigging und vieles mehr, um einmal einige Funktionen aufzuzählen, ermöglicht Blender.\cite{ble} Im Folgenden wird genauer auf den Ablauf bei der Modellierung der Szenenelemente und den Aufbau des Roboters eingegangen. Die Erklärungen umfassen größtenteils Abstrahierungen und sind keine Schritt für Schritt Anleitung zum Nachbauen.

\subsection{Visualisierung der Umgebung}
\label{vis_umgebung}
Bei der Modellierung der Umgebungsobjekte gab es zwei wichtige Faktoren. Einerseits die Umsetzung des geplanten Stils und andererseits die Anzahl der “Vertices“ möglichst klein zu halten. Üblicherweise werden, um das Training zu beschleunigen, mehrere Instanzen der Simulationsumgebung erstellt. Eine detailgetreue Modellierung würde dann dazu führen, dass sich deutlich mehr “Vertices“ in der Szene befinden. Diese benötigen bei der Darstellung mehr Rechenleistung und können somit den Trainingsprozess negativ beeinflussen. Beispielsweise könnte eine Folge des höheren Rechenaufwands weniger Instanzen der Szene sein. Dadurch würde die Dauer des Trainings sich um Minuten bis Stunden verzögen. Was wiederum dazu führt, dass weniger verschiedene Ansätze getestet werden können. Somit entsteht ein Dilemma zwischen der Generierung einer visuell ansprechenderen Umgebung und der damit einhergehenden erhöhten Trainingsdauer. Da der Fokus der Arbeit aber auf der Implementierung eines RL-Agenten liegt, ist der visuelle Aspekt eher zweitrangig. Somit muss ein Mittelweg gefunden werden, der eher in Richtung Performance getrimmt ist. 
\\
Mein Ziel für den stilistischen Teil der Modellierung war, dass keine oder nur selten scharfe Kanten zu erkennen sind. Dies lässt sich durch die Funktion „Shade Auto Smooth“ in der Blender Version 4.0 und höher umsetzen. In der Abbildung kann man den Unterschied noch einmal genauer erkennen. Um die klar erkennbaren Übergänge zu verhindern, muss der Winkel zwischen den Kanten eines Objektes, eine gewisse Gradzahl unterschreiten. Dafür kann man einerseits den Winkel in den Einstellungen anpassen. Wird der Winkel zu hoch gewählt, sieht die Beleuchtung des Objektes unnatürlich aus. Ist die Einstellung zu gering, sind die Kanten wieder erkennbar. Die andere Option ist die Erhöhung der Anzahl der Kanten, um die Übergänge natürlicher aussehen zu lassen. Dies führt aber wieder zu dem vorher angesprochenen Dilemma. 
\\
Nun gibt es zwei Ansätze für unterschiedliche Objektformen. Bei rechteckigen Objekten lohnt es sich den sogenannten „Bevel“ Modifier zu verwenden. Dieser fügt an den äußeren Kanten neue Topologie hinzu, um diese abzurunden. Dadurch reflektiert das einfallende Licht deutlich natürlicher und das modellierte Objekt wirkt realistischer. Dafür reicht es schon wenige Kanten hinzuzufügen, wodurch die Menge an „Vertices“ nur geringfügig steigt. Runde Modelle sind wiederum ein wenig komplizierter. Diese wirken bei genauerer Betrachtung erst rund, wenn die Anzahl an Kanten verhältnismäßig hoch ist. Dies führt automatisch dazu, dass runde Modelle mehr „Vertices“ benötigen als Rechteckige. Hier muss eher beachtet werden aus welcher Entfernung das Objekt betrachtet wird und wie hoch die Auflösung sein sollte, damit die Kanten nicht auffallen. 
\\
Meine Erfahrung in diesem Bereich liefert mir ungefähre Anhaltspunkte, welche Anzahl an „Vertices“ in Abhängigkeit von der Objektform gerechtfertigt sind. Für kleine rechteckige Objekte wie zum Beispiel die Artikel des Supermarktes habe ich mir eine Grenze von 1000 Vertices gesetzt. Runde Artikel hingegen können bis zu 3000 Vertices haben. Die Anzahl ist nicht besonders hoch und befindet sich eher im Low Poly Bereich.

\subsection{Visualisierung des Agenten}
\label{vis_agent}
Diese Grenzen gelten jedoch nicht für Objekte, die eher im Fokus liegen wie der Roboter. Hier sind deutlich höhere aufgelöste Topologien in Ordnung, da diese auch nur einmal pro Simulationsumgebung vorkommen. Für die Modellierung des Einkaufsroboters habe ich mir den Prototypen der TU Chemnitz als Anhaltspunkt ausgesucht siehe Abb. Der Roboter ist mit einem Greifarm ausgestattet und besitzt einen Korb in dem die eingesammelten Objekte gelagert werden können. 